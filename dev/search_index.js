var documenterSearchIndex = {"docs":
[{"location":"metrics/#Metrics-1","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"metrics/#","page":"Metrics","title":"Metrics","text":"KernelFunctions.jl relies on Distances.jl for computing the pairwise matrix. To do so a distance measure is needed for each kernel. Two very common ones can already be used : SqEuclidean and Euclidean. However all kernels do not rely on distances metrics respecting all the definitions. That's why two additional metrics come with the package : DotProduct (<x,y>) and Delta (δ(x,y)). Note that all base kernels must have a defined metric defined as :","category":"page"},{"location":"metrics/#","page":"Metrics","title":"Metrics","text":"    metric(::CustomKernel) = SqEuclidean()","category":"page"},{"location":"metrics/#Adding-a-new-metric-1","page":"Metrics","title":"Adding a new metric","text":"","category":"section"},{"location":"metrics/#","page":"Metrics","title":"Metrics","text":"If you want to create a new distance just implement the following :","category":"page"},{"location":"metrics/#","page":"Metrics","title":"Metrics","text":"struct Delta <: Distances.PreMetric\nend\n\n@inline function Distances._evaluate(::Delta,a::AbstractVector{T},b::AbstractVector{T}) where {T}\n    @boundscheck if length(a) != length(b)\n        throw(DimensionMismatch(\"first array has length $(length(a)) which does not match the length of the second, $(length(b)).\"))\n    end\n    return a==b\nend\n\n@inline (dist::Delta)(a::AbstractArray,b::AbstractArray) = Distances._evaluate(dist,a,b)\n@inline (dist::Delta)(a::Number,b::Number) = a==b","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  CurrentModule = KernelFunctions","category":"page"},{"location":"kernels/#Base-Kernels-1","page":"Kernel Functions","title":"Base Kernels","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"These are the basic kernels without any transformation of the data. They are the building blocks of KernelFunctions","category":"page"},{"location":"kernels/#Exponential-Kernels-1","page":"Kernel Functions","title":"Exponential Kernels","text":"","category":"section"},{"location":"kernels/#Exponential-Kernel-1","page":"Kernel Functions","title":"Exponential Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Exponential Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = expleft(-x-xright)","category":"page"},{"location":"kernels/#Square-Exponential-Kernel-1","page":"Kernel Functions","title":"Square Exponential Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Square Exponential Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = expleft(-x-x^2right)","category":"page"},{"location":"kernels/#Gamma-Exponential-Kernel-1","page":"Kernel Functions","title":"Gamma Exponential Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Gamma Exponential Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxgamma) = expleft(-x-x^2gammaright)","category":"page"},{"location":"kernels/#Matern-Kernels-1","page":"Kernel Functions","title":"Matern Kernels","text":"","category":"section"},{"location":"kernels/#Matern-Kernel-1","page":"Kernel Functions","title":"Matern Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Matern Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxnu) = frac2^1-nuGamma(nu)left(sqrt2nux-xright)K_nuleft(sqrt2nux-xright)","category":"page"},{"location":"kernels/#Matern-3/2-Kernel-1","page":"Kernel Functions","title":"Matern 3/2 Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Matern 3/2 Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = left(1+sqrt3x-xright)expleft(sqrt3x-xright)","category":"page"},{"location":"kernels/#Matern-5/2-Kernel-1","page":"Kernel Functions","title":"Matern 5/2 Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Matern 5/2 Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = left(1+sqrt5x-x+frac52x-x^2right)expleft(sqrt5x-xright)","category":"page"},{"location":"kernels/#Rational-Quadratic-1","page":"Kernel Functions","title":"Rational Quadratic","text":"","category":"section"},{"location":"kernels/#Rational-Quadratic-Kernel-1","page":"Kernel Functions","title":"Rational Quadratic Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Rational Quadratic Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxalpha) = left(1+fracx-x^2alpharight)^-alpha","category":"page"},{"location":"kernels/#Gamma-Rational-Quadratic-Kernel-1","page":"Kernel Functions","title":"Gamma Rational Quadratic Kernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Gamma Rational Quadratic Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxalphagamma) = left(1+fracx-x^2gammaalpharight)^-alpha","category":"page"},{"location":"kernels/#Polynomial-Kernels-1","page":"Kernel Functions","title":"Polynomial Kernels","text":"","category":"section"},{"location":"kernels/#LinearKernel-1","page":"Kernel Functions","title":"LinearKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Linear Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxc) = langle xxrangle + c","category":"page"},{"location":"kernels/#PolynomialKernel-1","page":"Kernel Functions","title":"PolynomialKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Polynomial Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxcd) = left(langle xxrangle + cright)^d","category":"page"},{"location":"kernels/#Periodic-Kernels-1","page":"Kernel Functions","title":"Periodic Kernels","text":"","category":"section"},{"location":"kernels/#PeriodicKernel-1","page":"Kernel Functions","title":"PeriodicKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxr) = expleft(-05 sum_i (sin (π(x_i - x_i))r_i)^2right)","category":"page"},{"location":"kernels/#Constant-Kernels-1","page":"Kernel Functions","title":"Constant Kernels","text":"","category":"section"},{"location":"kernels/#ConstantKernel-1","page":"Kernel Functions","title":"ConstantKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Constant Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxc) = c","category":"page"},{"location":"kernels/#WhiteKernel-1","page":"Kernel Functions","title":"WhiteKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The White Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = delta(x-x)","category":"page"},{"location":"kernels/#ZeroKernel-1","page":"Kernel Functions","title":"ZeroKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Zero Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xx) = 0","category":"page"},{"location":"kernels/#Composite-Kernels-1","page":"Kernel Functions","title":"Composite Kernels","text":"","category":"section"},{"location":"kernels/#TransformedKernel-1","page":"Kernel Functions","title":"TransformedKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Transformed Kernel is a kernel where input are transformed via a function f","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxfwidetilek) = widetildek(f(x)f(x))","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"Where k̃ is another kernel","category":"page"},{"location":"kernels/#ScaledKernel-1","page":"Kernel Functions","title":"ScaledKernel","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Scalar Kernel is defined as","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxsigma^2widetildek) = sigma^2widetildek(xx)","category":"page"},{"location":"kernels/#KernelSum-1","page":"Kernel Functions","title":"KernelSum","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Kernel Sum is defined as a sum of kernel","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxw_ik_i) = sum_i w_i k_i(xx)","category":"page"},{"location":"kernels/#KernelProduct-1","page":"Kernel Functions","title":"KernelProduct","text":"","category":"section"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"The Kernel Product is defined as a product of kernel","category":"page"},{"location":"kernels/#","page":"Kernel Functions","title":"Kernel Functions","text":"  k(xxk_i) = prod_i k_i(xx)","category":"page"},{"location":"api/#API-Library-1","page":"API","title":"API Library","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#","page":"API","title":"API","text":"CurrentModule = KernelFunctions","category":"page"},{"location":"api/#Module-1","page":"API","title":"Module","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"KernelFunctions","category":"page"},{"location":"api/#KernelFunctions.KernelFunctions","page":"API","title":"KernelFunctions.KernelFunctions","text":"KernelFunctions. Github Documentation\n\n\n\n\n\n","category":"module"},{"location":"api/#Base-Kernels-1","page":"API","title":"Base Kernels","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"SqExponentialKernel\nExponentialKernel\nGammaExponentialKernel\nExponentiatedKernel\nMaternKernel\nMatern32Kernel\nMatern52Kernel\nLinearKernel\nPolynomialKernel\nRationalQuadraticKernel\nGammaRationalQuadraticKernel\nPeriodicKernel\nZeroKernel\nConstantKernel\nWhiteKernel","category":"page"},{"location":"api/#KernelFunctions.SqExponentialKernel","page":"API","title":"KernelFunctions.SqExponentialKernel","text":"SqExponentialKernel()\n\nThe squared exponential kernel is a Mercer kernel given by the formula:\n\n    κ(x,y) = exp(-‖x-y‖²)\n\nCan also be called via SEKernel, GaussianKernel or SEKernel. See also ExponentialKernel for a related form of the kernel or GammaExponentialKernel for a generalization.\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ExponentialKernel","page":"API","title":"KernelFunctions.ExponentialKernel","text":"ExponentialKernel()\n\nThe exponential kernel is a Mercer kernel given by the formula:\n\n    κ(x,y) = exp(-‖x-y‖)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.GammaExponentialKernel","page":"API","title":"KernelFunctions.GammaExponentialKernel","text":"GammaExponentialKernel(; γ = 2.0)\n\nThe γ-exponential kernel is an isotropic Mercer kernel given by the formula:\n\n    κ(x,y) = exp(-‖x-y‖^(2γ))\n\nWhere γ > 0, (the keyword γ can be replaced by gamma) For γ = 1, see SqExponentialKernel and γ = 0.5, see ExponentialKernel\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ExponentiatedKernel","page":"API","title":"KernelFunctions.ExponentiatedKernel","text":"ExponentiatedKernel()\n\nThe exponentiated kernel is a Mercer kernel given by:\n\n    κ(x,y) = exp(xᵀy)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.MaternKernel","page":"API","title":"KernelFunctions.MaternKernel","text":"MaternKernel(; ν = 1.0)\n\nThe matern kernel is a Mercer kernel given by the formula:\n\n    κ(x,y) = 2^{1-ν}/Γ(ν)*(√(2ν)‖x-y‖)^ν K_ν(√(2ν)‖x-y‖)\n\nFor ν=n+1/2, n=0,1,2,... it can be simplified and you should instead use ExponentialKernel for n=0, Matern32Kernel, for n=1, Matern52Kernel for n=2 and SqExponentialKernel for n=∞.\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.Matern32Kernel","page":"API","title":"KernelFunctions.Matern32Kernel","text":"Matern32Kernel()\n\nThe matern 3/2 kernel is a Mercer kernel given by the formula:\n\n    κ(x,y) = (1+√(3)‖x-y‖)exp(-√(3)‖x-y‖)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.Matern52Kernel","page":"API","title":"KernelFunctions.Matern52Kernel","text":"Matern52Kernel()\n\nThe matern 5/2 kernel is a Mercer kernel given by the formula:\n\n    κ(x,y) = (1+√(5)‖x-y‖ + 5/3‖x-y‖^2)exp(-√(5)‖x-y‖)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.LinearKernel","page":"API","title":"KernelFunctions.LinearKernel","text":"LinearKernel(; c = 0.0)\n\nThe linear kernel is a Mercer kernel given by\n\n    κ(x,y) = xᵀy + c\n\nWhere c is a real number\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.PolynomialKernel","page":"API","title":"KernelFunctions.PolynomialKernel","text":"PolynomialKernel(; d = 2.0, c = 0.0)\n\nThe polynomial kernel is a Mercer kernel given by\n\n    κ(x,y) = (xᵀy + c)^d\n\nWhere c is a real number, and d is a shape parameter bigger than 1. For d = 1 see LinearKernel\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.RationalQuadraticKernel","page":"API","title":"KernelFunctions.RationalQuadraticKernel","text":"RationalQuadraticKernel(; α = 2.0)\n\nThe rational-quadratic kernel is a Mercer kernel given by the formula:\n\n    κ(x,y)=(1+||x−y||²/α)^(-α)\n\nwhere α is a shape parameter of the Euclidean distance. Check GammaRationalQuadraticKernel for a generalization.\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.GammaRationalQuadraticKernel","page":"API","title":"KernelFunctions.GammaRationalQuadraticKernel","text":"GammaRationalQuadraticKernel([ρ=1.0[,α=2.0[,γ=2.0]]]) The Gamma-rational-quadratic kernel is an isotropic Mercer kernel given by the formula:\n\n    κ(x,y)=(1+ρ^(2γ)||x−y||^(2γ)/α)^(-α)\n\nwhere α is a shape parameter of the Euclidean distance and γ is another shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.PeriodicKernel","page":"API","title":"KernelFunctions.PeriodicKernel","text":"PeriodicKernel(r::AbstractVector)\nPeriodicKernel(dims::Int)\nPeriodicKernel(T::DataType, dims::Int)\n\nPeriodic Kernel as described in http://www.inference.org.uk/mackay/gpB.pdf eq. 47.\n\n    κ(x,y) = exp( - 0.5 sum_i(sin (π(x_i - y_i))/r_i))\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ZeroKernel","page":"API","title":"KernelFunctions.ZeroKernel","text":"ZeroKernel()\n\nCreate a kernel that always returning zero\n\n    κ(x,y) = 0.0\n\nThe output type depends of x and y\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ConstantKernel","page":"API","title":"KernelFunctions.ConstantKernel","text":"ConstantKernel(; c=1.0)\n\nKernel function always returning a constant value c\n\n    κ(x,y) = c\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.WhiteKernel","page":"API","title":"KernelFunctions.WhiteKernel","text":"WhiteKernel()\n\n    κ(x,y) = δ(x,y)\n\nKernel function working as an equivalent to add white noise. Can also be called via EyeKernel()\n\n\n\n\n\n","category":"type"},{"location":"api/#Composite-Kernels-1","page":"API","title":"Composite Kernels","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"TransformedKernel\nScaledKernel\nKernelSum\nKernelProduct","category":"page"},{"location":"api/#KernelFunctions.TransformedKernel","page":"API","title":"KernelFunctions.TransformedKernel","text":"TransformedKernel(k::Kernel,t::Transform)\n\nReturn a kernel where inputs are pretransformed by t : k(t(x),t(x')) Can also be called via transform : transform(k, t)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ScaledKernel","page":"API","title":"KernelFunctions.ScaledKernel","text":"ScaledKernel(k::Kernel, σ²::Real)\n\nReturn a kernel premultiplied by the variance σ² : σ² k(x,x')\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.KernelSum","page":"API","title":"KernelFunctions.KernelSum","text":"KernelSum(kernels::Array{Kernel}; weights::Array{Real}=ones(length(kernels)))\n\nCreate a positive weighted sum of kernels. All weights should be positive. One can also use the operator +\n\n    k1 = SqExponentialKernel()\n    k2 = LinearKernel()\n    k = KernelSum([k1, k2]) == k1 + k2\n    kernelmatrix(k, X) == kernelmatrix(k1, X) .+ kernelmatrix(k2, X)\n    kernelmatrix(k, X) == kernelmatrix(k1 + k2, X)\n    kweighted = 0.5* k1 + 2.0*k2 == KernelSum([k1, k2], weights = [0.5, 2.0])\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.KernelProduct","page":"API","title":"KernelFunctions.KernelProduct","text":"KernelProduct(kernels::Array{Kernel})\n\nCreate a product of kernels. One can also use the operator * :\n\n    k1 = SqExponentialKernel()\n    k2 = LinearKernel()\n    k = KernelProduct([k1, k2]) == k1 * k2\n    kernelmatrix(k, X) == kernelmatrix(k1, X) .* kernelmatrix(k2, X)\n    kernelmatrix(k, X) == kernelmatrix(k1 * k2, X)\n\n\n\n\n\n","category":"type"},{"location":"api/#Transforms-1","page":"API","title":"Transforms","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Transform\nIdentityTransform\nScaleTransform\nLowRankTransform\nFunctionTransform\nChainTransform","category":"page"},{"location":"api/#KernelFunctions.Transform","page":"API","title":"KernelFunctions.Transform","text":"Abstract type defining a slice-wise transformation on an input matrix\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.IdentityTransform","page":"API","title":"KernelFunctions.IdentityTransform","text":"IdentityTransform Return exactly the input\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ScaleTransform","page":"API","title":"KernelFunctions.ScaleTransform","text":"Scale Transform\n\n    l = 2.0\n    tr = ScaleTransform(l)\n\nMultiply every element of the input by l\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.LowRankTransform","page":"API","title":"KernelFunctions.LowRankTransform","text":"LowRankTransform\n\n    P = rand(10,5)\n    tr = LowRankTransform(P)\n\nApply the low-rank projection realised by the matrix P The second dimension of P must match the number of features of the target.\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.FunctionTransform","page":"API","title":"KernelFunctions.FunctionTransform","text":"FunctionTransform\n\n    f(x) = abs.(x)\n    tr = FunctionTransform(f)\n\nTake a function or object f as an argument which is going to act on each vector individually. Make sure that f is supposed to act on a vector by eventually using broadcasting For example f(x)=sin(x) -> f(x)=sin.(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#KernelFunctions.ChainTransform","page":"API","title":"KernelFunctions.ChainTransform","text":"Chain a series of transform, here t1 will be called first\n\n    t1 = ScaleTransform()\n    t2 = LowRankTransform(rand(3,4))\n    ct = ChainTransform([t1,t2]) #t1 will be called first\n    ct == t2∘t1\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions-1","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"kernelmatrix\nkernelmatrix!\nkerneldiagmatrix\nkerneldiagmatrix!\nkernelpdmat\nkernelkronmat\ntransform","category":"page"},{"location":"api/#KernelFunctions.kernelmatrix","page":"API","title":"KernelFunctions.kernelmatrix","text":"kernelmatrix(κ::Kernel, X::Matrix; obsdim::Int = 2)\nkernelmatrix(κ::Kernel, X::Matrix, Y::Matrix; obsdim::Int = 2)\n\nCalculate the kernel matrix of X (and Y) with respect to kernel κ. obsdim = 1 means the matrix X (and Y) has size #samples x #dimension obsdim = 2 means the matrix X (and Y) has size #dimension x #samples\n\n\n\n\n\n","category":"function"},{"location":"api/#KernelFunctions.kernelmatrix!","page":"API","title":"KernelFunctions.kernelmatrix!","text":"kernelmatrix!(K::Matrix, κ::Kernel, X::Matrix; obsdim::Integer = 2)\nkernelmatrix!(K::Matrix, κ::Kernel, X::Matrix, Y::Matrix; obsdim::Integer = 2)\n\nIn-place version of kernelmatrix where pre-allocated matrix K will be overwritten with the kernel matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#KernelFunctions.kerneldiagmatrix","page":"API","title":"KernelFunctions.kerneldiagmatrix","text":"kerneldiagmatrix(κ::Kernel, X::Matrix; obsdim::Int = 2)\n\nCalculate the diagonal matrix of X with respect to kernel κ obsdim = 1 means the matrix X has size #samples x #dimension obsdim = 2 means the matrix X has size #dimension x #samples\n\n\n\n\n\n","category":"function"},{"location":"api/#KernelFunctions.kerneldiagmatrix!","page":"API","title":"KernelFunctions.kerneldiagmatrix!","text":"kerneldiagmatrix!(K::AbstractVector,κ::Kernel, X::Matrix; obsdim::Int = 2)\n\nIn place version of kerneldiagmatrix\n\n\n\n\n\n","category":"function"},{"location":"api/#KernelFunctions.transform","page":"API","title":"KernelFunctions.transform","text":"    transform(k::BaseKernel, t::Transform) (1)\n    transform(k::BaseKernel, ρ::Real) (2)\n    transform(k::BaseKernel, ρ::AbstractVector) (3)\n\n(1) Create a TransformedKernel with transform t and kernel k (2) Same as (1) with a ScaleTransform with scale ρ (3) Same as (1) with an ARDTransform with scales ρ\n\n\n\n\n\n","category":"function"},{"location":"api/#Index-1","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Pages = [\"api.md\"]\nModule = [\"KernelFunctions\"]\nOrder = [:type, :function]","category":"page"},{"location":"theory/#","page":"Theory","title":"Theory","text":"See Wikipedia article","category":"page"},{"location":"create_kernel/#Creating-your-own-kernel-1","page":"Custom Kernels","title":"Creating your own kernel","text":"","category":"section"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"KernelFunctions.jl contains the most popular kernels already but you might want to make your own!","category":"page"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"Here is for example how one can define the Squared Exponential Kernel again :","category":"page"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"struct MyKernel <: Kernel end\n\nKernelFunctions.kappa(::MyKernel, d2::Real) = exp(-d2)\nKernelFunctions.metric(::MyKernel) = SqEuclidean()","category":"page"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"For a \"Base\" kernel, where the kernel function is simply a function applied on some metric between two vectors of real, you only need to:","category":"page"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"Define your struct inheriting from Kernel.\nDefine a kappa function.\nDefine the metric used SqEuclidean, DotProduct etc. Note that the term \"metric\" is here overabused.\nOptional : Define any parameter of your kernel as trainable by Flux.jl if you want to perform optimization on the parameters. We recommend wrapping all parameters in arrays to allow them to be mutable.","category":"page"},{"location":"create_kernel/#","page":"Custom Kernels","title":"Custom Kernels","text":"Once these functions are defined, you can use all the wrapping functions of KernelFuntions.jl","category":"page"},{"location":"transform/#Transform-1","page":"Transform","title":"Transform","text":"","category":"section"},{"location":"transform/#","page":"Transform","title":"Transform","text":"Transform is the object that takes care of transforming the input data before distances are being computed. It can be as standard as IdentityTransform returning the same input, or multiplying the data by a scalar with ScaleTransform or by a vector with ARDTransform. There is a more general Transform: FunctionTransform that uses a function and apply it on each vector via mapslices. You can also create a pipeline of Transform via TransformChain. For example LowRankTransform(rand(10,5))∘ScaleTransform(2.0).","category":"page"},{"location":"transform/#","page":"Transform","title":"Transform","text":"One apply a transformation on a matrix or a vector via KernelFunctions.apply(t::Transform,v::AbstractVecOrMat)","category":"page"},{"location":"transform/#","page":"Transform","title":"Transform","text":"Check the list on the API page","category":"page"},{"location":"userguide/#User-guide-1","page":"User Guide","title":"User guide","text":"","category":"section"},{"location":"userguide/#Kernel-creation-1","page":"User Guide","title":"Kernel creation","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"To create a kernel chose one of the kernels proposed, see Kernels, or create your own, see Creating Kernels For example to create a square exponential kernel","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = SqExponentialKernel()","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Instead of having lengthscale(s) for each kernel we use Transform objects (see Transform) which are directly going to act on the inputs before passing them to the kernel. For example to premultiply the input by 2.0 we create the kernel the following options are possible","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = transform(SqExponentialKernel(),ScaleTransform(2.0)) # returns a TransformedKernel\n  k = @kernel SqExponentialKernel() l=2.0 # Will be available soon\n  k = TransformedKernel(SqExponentialKernel(),ScaleTransform(2.0))","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Check the Transform page to see the other options. To premultiply the kernel by a variance, you can use * or create a ScaledKernel","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = 3.0*SqExponentialKernel()\n  k = ScaledKernel(SqExponentialKernel(),3.0)\n  @kernel 3.0*SqExponentialKernel()","category":"page"},{"location":"userguide/#Using-a-kernel-function-1","page":"User Guide","title":"Using a kernel function","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"To compute the kernel function on two vectors you can call","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = SqExponentialKernel()\n  x1 = rand(3); x2 = rand(3)\n  kappa(k,x1,x2) == k(x1,x2) # Syntactic sugar","category":"page"},{"location":"userguide/#Creating-a-kernel-matrix-1","page":"User Guide","title":"Creating a kernel matrix","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Kernel matrices can be created via the kernelmatrix function or kerneldiagmatrix for only the diagonal. An important argument to give is the dimensionality of the input obsdim. It tells if the matrix is of the type # samples X # features (obsdim=1) or # features X # samples(obsdim=2) (similarly to Distances.jl) For example:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = SqExponentialKernel()\n  A = rand(10,5)\n  kernelmatrix(k,A,obsdim=1) # Return a 10x10 matrix\n  kernelmatrix(k,A,obsdim=2) # Return a 5x5 matrix\n  k(A,obsdim=1) # Syntactic sugar","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"We also support specific kernel matrices outputs:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"For a positive-definite matrix objectPDMat from PDMats.jl, you can call the following:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  using PDMats\n  k = SqExponentialKernel()\n  K = kernelpdmat(k,A,obsdim=1) # PDMat","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"It will create a matrix and in case of bad conditionning will add some diagonal noise until the matrix is considered PSD, it will then return a PDMat object. For this method to work in your code you need to include using PDMats first","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"For a Kronecker matrix, we rely on Kronecker.jl. Here are two examples:","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"using Kronecker\nx = range(0,1,length=10)\ny = range(0,1,length=50)\nK = kernelkronmat(k,[x,y]) # Kronecker matrix\nK = kernelkronmat(k,x,5) # Kronecker matrix","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"Make sure that k is a vector compatible with such constructions (with iskroncompatible). Both method will return a . For those methods to work in your code you need to include using Kronecker first","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"For a Nystrom approximation : kernelmatrix(nystrom(k, X, ρ, obsdim = 1)) where ρ is the proportion of sampled used.","category":"page"},{"location":"userguide/#Composite-kernels-1","page":"User Guide","title":"Composite kernels","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"One can create combinations of kernels via KernelSum and KernelProduct or using simple operators + and *. For example :","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k1 = SqExponentialKernel()\n  k2 = Matern32Kernel()\n  k = 0.5*k1 + 0.2*k2 # KernelSum\n  k = k1*k2 # KernelProduct","category":"page"},{"location":"userguide/#Kernel-Parameters-1","page":"User Guide","title":"Kernel Parameters","text":"","category":"section"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"What if you want to differentiate through the kernel parameters? Even in a highly nested structure such as :","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  k = transform(0.5*SqExponentialKernel()*MaternKernel()+0.2*(transform(LinearKernel(),2.0)+PolynomialKernel()),[0.1,0.5])","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"One can get the array of parameters to optimize via params from Flux.jl","category":"page"},{"location":"userguide/#","page":"User Guide","title":"User Guide","text":"  using Flux\n  params(k)","category":"page"},{"location":"#KernelFunctions.jl-1","page":"Home","title":"KernelFunctions.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Model agnostic kernel functions compatible with automatic differentiation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"KernelFunctions.jl is a general purpose kernel package. It aims at providing a flexible framework for creating kernels and manipulating them. The main goals of this package compared to its predecessors/concurrents in MLKernels.jl, Stheno.jl, GaussianProcesses.jl and AugmentedGaussianProcesses.jl are:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Automatic Differentation compatibility: all kernel functions should be differentiable via packages like ForwardDiff.jl or Zygote.jl\nFlexibility: operations between kernels should be fluid and easy without breaking.\nPlug-and-play: including the kernels before/after other steps should be straightforward.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The methodology of how kernels are computed is quite simple and is done in three phases :","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A Transform object is applied sample-wise on every sample\nThe pairwise matrix is computed using Distances.jl by using a Metric proper to each kernel\nThe Kernel function is applied element-wise on the pairwise matrix","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick introduction on how to use it go to User guide","category":"page"},{"location":"example/#Examples-(WIP)-1","page":"Examples","title":"Examples (WIP)","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"Here are a few examples of known complex kernels and how to do them. Or how to use kernels in a certain context","category":"page"},{"location":"example/#Kernel-Ridge-Regression-1","page":"Examples","title":"Kernel Ridge Regression","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"Make a simple example of kernel ridge regression","category":"page"},{"location":"example/#Gaussian-Process-Regression-1","page":"Examples","title":"Gaussian Process Regression","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"Make a simple example of gaussian process regression","category":"page"},{"location":"example/#Deep-Kernel-Learning-1","page":"Examples","title":"Deep Kernel Learning","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"Put a Flux neural net in front of the kernel cf. Wilson paper","category":"page"},{"location":"example/#Kernel-Selection-1","page":"Examples","title":"Kernel Selection","text":"","category":"section"},{"location":"example/#","page":"Examples","title":"Examples","text":"Create a large collection of kernels and optimize the weights cf AISTATS 2018 paper","category":"page"}]
}
